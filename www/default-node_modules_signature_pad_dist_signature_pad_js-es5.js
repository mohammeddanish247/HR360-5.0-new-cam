(function () {
  "use strict";

  function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

  function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }

  function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }

  (self["webpackChunkhr360"] = self["webpackChunkhr360"] || []).push([["default-node_modules_signature_pad_dist_signature_pad_js"], {
    /***/
    35734:
    /*!**********************************************************!*\
      !*** ./node_modules/signature_pad/dist/signature_pad.js ***!
      \**********************************************************/

    /***/
    function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /*!
       * Signature Pad v3.0.0-beta.4 | https://github.com/szimek/signature_pad
       * (c) 2020 Szymon Nowak | Released under the MIT license
       */


      var Point = /*#__PURE__*/function () {
        function Point(x, y, time) {
          _classCallCheck(this, Point);

          this.x = x;
          this.y = y;
          this.time = time || Date.now();
        }

        _createClass(Point, [{
          key: "distanceTo",
          value: function distanceTo(start) {
            return Math.sqrt(Math.pow(this.x - start.x, 2) + Math.pow(this.y - start.y, 2));
          }
        }, {
          key: "equals",
          value: function equals(other) {
            return this.x === other.x && this.y === other.y && this.time === other.time;
          }
        }, {
          key: "velocityFrom",
          value: function velocityFrom(start) {
            return this.time !== start.time ? this.distanceTo(start) / (this.time - start.time) : 0;
          }
        }]);

        return Point;
      }();

      var Bezier = /*#__PURE__*/function () {
        function Bezier(startPoint, control2, control1, endPoint, startWidth, endWidth) {
          _classCallCheck(this, Bezier);

          this.startPoint = startPoint;
          this.control2 = control2;
          this.control1 = control1;
          this.endPoint = endPoint;
          this.startWidth = startWidth;
          this.endWidth = endWidth;
        }

        _createClass(Bezier, [{
          key: "length",
          value: function length() {
            var steps = 10;
            var length = 0;
            var px;
            var py;

            for (var i = 0; i <= steps; i += 1) {
              var t = i / steps;
              var cx = this.point(t, this.startPoint.x, this.control1.x, this.control2.x, this.endPoint.x);
              var cy = this.point(t, this.startPoint.y, this.control1.y, this.control2.y, this.endPoint.y);

              if (i > 0) {
                var xdiff = cx - px;
                var ydiff = cy - py;
                length += Math.sqrt(xdiff * xdiff + ydiff * ydiff);
              }

              px = cx;
              py = cy;
            }

            return length;
          }
        }, {
          key: "point",
          value: function point(t, start, c1, c2, end) {
            return start * (1.0 - t) * (1.0 - t) * (1.0 - t) + 3.0 * c1 * (1.0 - t) * (1.0 - t) * t + 3.0 * c2 * (1.0 - t) * t * t + end * t * t * t;
          }
        }], [{
          key: "fromPoints",
          value: function fromPoints(points, widths) {
            var c2 = this.calculateControlPoints(points[0], points[1], points[2]).c2;
            var c3 = this.calculateControlPoints(points[1], points[2], points[3]).c1;
            return new Bezier(points[1], c2, c3, points[2], widths.start, widths.end);
          }
        }, {
          key: "calculateControlPoints",
          value: function calculateControlPoints(s1, s2, s3) {
            var dx1 = s1.x - s2.x;
            var dy1 = s1.y - s2.y;
            var dx2 = s2.x - s3.x;
            var dy2 = s2.y - s3.y;
            var m1 = {
              x: (s1.x + s2.x) / 2.0,
              y: (s1.y + s2.y) / 2.0
            };
            var m2 = {
              x: (s2.x + s3.x) / 2.0,
              y: (s2.y + s3.y) / 2.0
            };
            var l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
            var l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
            var dxm = m1.x - m2.x;
            var dym = m1.y - m2.y;
            var k = l2 / (l1 + l2);
            var cm = {
              x: m2.x + dxm * k,
              y: m2.y + dym * k
            };
            var tx = s2.x - cm.x;
            var ty = s2.y - cm.y;
            return {
              c1: new Point(m1.x + tx, m1.y + ty),
              c2: new Point(m2.x + tx, m2.y + ty)
            };
          }
        }]);

        return Bezier;
      }();

      function throttle(fn) {
        var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 250;
        var previous = 0;
        var timeout = null;
        var result;
        var storedContext;
        var storedArgs;

        var later = function later() {
          previous = Date.now();
          timeout = null;
          result = fn.apply(storedContext, storedArgs);

          if (!timeout) {
            storedContext = null;
            storedArgs = [];
          }
        };

        return function wrapper() {
          var now = Date.now();
          var remaining = wait - (now - previous);
          storedContext = this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          storedArgs = args;

          if (remaining <= 0 || remaining > wait) {
            if (timeout) {
              clearTimeout(timeout);
              timeout = null;
            }

            previous = now;
            result = fn.apply(storedContext, storedArgs);

            if (!timeout) {
              storedContext = null;
              storedArgs = [];
            }
          } else if (!timeout) {
            timeout = window.setTimeout(later, remaining);
          }

          return result;
        };
      }

      var SignaturePad = /*#__PURE__*/function () {
        function SignaturePad(canvas) {
          var _this = this;

          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          _classCallCheck(this, SignaturePad);

          this.canvas = canvas;
          this.options = options;

          this._handleMouseDown = function (event) {
            if (event.which === 1) {
              _this._mouseButtonDown = true;

              _this._strokeBegin(event);
            }
          };

          this._handleMouseMove = function (event) {
            if (_this._mouseButtonDown) {
              _this._strokeMoveUpdate(event);
            }
          };

          this._handleMouseUp = function (event) {
            if (event.which === 1 && _this._mouseButtonDown) {
              _this._mouseButtonDown = false;

              _this._strokeEnd(event);
            }
          };

          this._handleTouchStart = function (event) {
            event.preventDefault();

            if (event.targetTouches.length === 1) {
              var touch = event.changedTouches[0];

              _this._strokeBegin(touch);
            }
          };

          this._handleTouchMove = function (event) {
            event.preventDefault();
            var touch = event.targetTouches[0];

            _this._strokeMoveUpdate(touch);
          };

          this._handleTouchEnd = function (event) {
            var wasCanvasTouched = event.target === _this.canvas;

            if (wasCanvasTouched) {
              event.preventDefault();
              var touch = event.changedTouches[0];

              _this._strokeEnd(touch);
            }
          };

          this.velocityFilterWeight = options.velocityFilterWeight || 0.7;
          this.minWidth = options.minWidth || 0.5;
          this.maxWidth = options.maxWidth || 2.5;
          this.throttle = 'throttle' in options ? options.throttle : 16;
          this.minDistance = 'minDistance' in options ? options.minDistance : 5;

          this.dotSize = options.dotSize || function dotSize() {
            return (this.minWidth + this.maxWidth) / 2;
          };

          this.penColor = options.penColor || 'black';
          this.backgroundColor = options.backgroundColor || 'rgba(0,0,0,0)';
          this.onBegin = options.onBegin;
          this.onEnd = options.onEnd;
          this._strokeMoveUpdate = this.throttle ? throttle(SignaturePad.prototype._strokeUpdate, this.throttle) : SignaturePad.prototype._strokeUpdate;
          this._ctx = canvas.getContext('2d');
          this.clear();
          this.on();
        }

        _createClass(SignaturePad, [{
          key: "clear",
          value: function clear() {
            var ctx = this._ctx,
                canvas = this.canvas;
            ctx.fillStyle = this.backgroundColor;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            this._data = [];

            this._reset();

            this._isEmpty = true;
          }
        }, {
          key: "fromDataURL",
          value: function fromDataURL(dataUrl) {
            var _this2 = this;

            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var callback = arguments.length > 2 ? arguments[2] : undefined;
            var image = new Image();
            var ratio = options.ratio || window.devicePixelRatio || 1;
            var width = options.width || this.canvas.width / ratio;
            var height = options.height || this.canvas.height / ratio;

            this._reset();

            image.onload = function () {
              _this2._ctx.drawImage(image, 0, 0, width, height);

              if (callback) {
                callback();
              }
            };

            image.onerror = function (error) {
              if (callback) {
                callback(error);
              }
            };

            image.src = dataUrl;
            this._isEmpty = false;
          }
        }, {
          key: "toDataURL",
          value: function toDataURL() {
            var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'image/png';
            var encoderOptions = arguments.length > 1 ? arguments[1] : undefined;

            switch (type) {
              case 'image/svg+xml':
                return this._toSVG();

              default:
                return this.canvas.toDataURL(type, encoderOptions);
            }
          }
        }, {
          key: "on",
          value: function on() {
            this.canvas.style.touchAction = 'none';
            this.canvas.style.msTouchAction = 'none';

            if (window.PointerEvent) {
              this._handlePointerEvents();
            } else {
              this._handleMouseEvents();

              if ('ontouchstart' in window) {
                this._handleTouchEvents();
              }
            }
          }
        }, {
          key: "off",
          value: function off() {
            this.canvas.style.touchAction = 'auto';
            this.canvas.style.msTouchAction = 'auto';
            this.canvas.removeEventListener('pointerdown', this._handleMouseDown);
            this.canvas.removeEventListener('pointermove', this._handleMouseMove);
            document.removeEventListener('pointerup', this._handleMouseUp);
            this.canvas.removeEventListener('mousedown', this._handleMouseDown);
            this.canvas.removeEventListener('mousemove', this._handleMouseMove);
            document.removeEventListener('mouseup', this._handleMouseUp);
            this.canvas.removeEventListener('touchstart', this._handleTouchStart);
            this.canvas.removeEventListener('touchmove', this._handleTouchMove);
            this.canvas.removeEventListener('touchend', this._handleTouchEnd);
          }
        }, {
          key: "isEmpty",
          value: function isEmpty() {
            return this._isEmpty;
          }
        }, {
          key: "fromData",
          value: function fromData(pointGroups) {
            var _this3 = this;

            this.clear();

            this._fromData(pointGroups, function (_ref) {
              var color = _ref.color,
                  curve = _ref.curve;
              return _this3._drawCurve({
                color: color,
                curve: curve
              });
            }, function (_ref2) {
              var color = _ref2.color,
                  point = _ref2.point;
              return _this3._drawDot({
                color: color,
                point: point
              });
            });

            this._data = pointGroups;
          }
        }, {
          key: "toData",
          value: function toData() {
            return this._data;
          }
        }, {
          key: "_strokeBegin",
          value: function _strokeBegin(event) {
            var newPointGroup = {
              color: this.penColor,
              points: []
            };

            if (typeof this.onBegin === 'function') {
              this.onBegin(event);
            }

            this._data.push(newPointGroup);

            this._reset();

            this._strokeUpdate(event);
          }
        }, {
          key: "_strokeUpdate",
          value: function _strokeUpdate(event) {
            if (this._data.length === 0) {
              this._strokeBegin(event);

              return;
            }

            var x = event.clientX;
            var y = event.clientY;

            var point = this._createPoint(x, y);

            var lastPointGroup = this._data[this._data.length - 1];
            var lastPoints = lastPointGroup.points;
            var lastPoint = lastPoints.length > 0 && lastPoints[lastPoints.length - 1];
            var isLastPointTooClose = lastPoint ? point.distanceTo(lastPoint) <= this.minDistance : false;
            var color = lastPointGroup.color;

            if (!lastPoint || !(lastPoint && isLastPointTooClose)) {
              var curve = this._addPoint(point);

              if (!lastPoint) {
                this._drawDot({
                  color: color,
                  point: point
                });
              } else if (curve) {
                this._drawCurve({
                  color: color,
                  curve: curve
                });
              }

              lastPoints.push({
                time: point.time,
                x: point.x,
                y: point.y
              });
            }
          }
        }, {
          key: "_strokeEnd",
          value: function _strokeEnd(event) {
            this._strokeUpdate(event);

            if (typeof this.onEnd === 'function') {
              this.onEnd(event);
            }
          }
        }, {
          key: "_handlePointerEvents",
          value: function _handlePointerEvents() {
            this._mouseButtonDown = false;
            this.canvas.addEventListener('pointerdown', this._handleMouseDown);
            this.canvas.addEventListener('pointermove', this._handleMouseMove);
            document.addEventListener('pointerup', this._handleMouseUp);
          }
        }, {
          key: "_handleMouseEvents",
          value: function _handleMouseEvents() {
            this._mouseButtonDown = false;
            this.canvas.addEventListener('mousedown', this._handleMouseDown);
            this.canvas.addEventListener('mousemove', this._handleMouseMove);
            document.addEventListener('mouseup', this._handleMouseUp);
          }
        }, {
          key: "_handleTouchEvents",
          value: function _handleTouchEvents() {
            this.canvas.addEventListener('touchstart', this._handleTouchStart);
            this.canvas.addEventListener('touchmove', this._handleTouchMove);
            this.canvas.addEventListener('touchend', this._handleTouchEnd);
          }
        }, {
          key: "_reset",
          value: function _reset() {
            this._lastPoints = [];
            this._lastVelocity = 0;
            this._lastWidth = (this.minWidth + this.maxWidth) / 2;
            this._ctx.fillStyle = this.penColor;
          }
        }, {
          key: "_createPoint",
          value: function _createPoint(x, y) {
            var rect = this.canvas.getBoundingClientRect();
            return new Point(x - rect.left, y - rect.top, new Date().getTime());
          }
        }, {
          key: "_addPoint",
          value: function _addPoint(point) {
            var _lastPoints = this._lastPoints;

            _lastPoints.push(point);

            if (_lastPoints.length > 2) {
              if (_lastPoints.length === 3) {
                _lastPoints.unshift(_lastPoints[0]);
              }

              var widths = this._calculateCurveWidths(_lastPoints[1], _lastPoints[2]);

              var curve = Bezier.fromPoints(_lastPoints, widths);

              _lastPoints.shift();

              return curve;
            }

            return null;
          }
        }, {
          key: "_calculateCurveWidths",
          value: function _calculateCurveWidths(startPoint, endPoint) {
            var velocity = this.velocityFilterWeight * endPoint.velocityFrom(startPoint) + (1 - this.velocityFilterWeight) * this._lastVelocity;

            var newWidth = this._strokeWidth(velocity);

            var widths = {
              end: newWidth,
              start: this._lastWidth
            };
            this._lastVelocity = velocity;
            this._lastWidth = newWidth;
            return widths;
          }
        }, {
          key: "_strokeWidth",
          value: function _strokeWidth(velocity) {
            return Math.max(this.maxWidth / (velocity + 1), this.minWidth);
          }
        }, {
          key: "_drawCurveSegment",
          value: function _drawCurveSegment(x, y, width) {
            var ctx = this._ctx;
            ctx.moveTo(x, y);
            ctx.arc(x, y, width, 0, 2 * Math.PI, false);
            this._isEmpty = false;
          }
        }, {
          key: "_drawCurve",
          value: function _drawCurve(_ref3) {
            var color = _ref3.color,
                curve = _ref3.curve;
            var ctx = this._ctx;
            var widthDelta = curve.endWidth - curve.startWidth;
            var drawSteps = Math.floor(curve.length()) * 2;
            ctx.beginPath();
            ctx.fillStyle = color;

            for (var i = 0; i < drawSteps; i += 1) {
              var t = i / drawSteps;
              var tt = t * t;
              var ttt = tt * t;
              var u = 1 - t;
              var uu = u * u;
              var uuu = uu * u;
              var x = uuu * curve.startPoint.x;
              x += 3 * uu * t * curve.control1.x;
              x += 3 * u * tt * curve.control2.x;
              x += ttt * curve.endPoint.x;
              var y = uuu * curve.startPoint.y;
              y += 3 * uu * t * curve.control1.y;
              y += 3 * u * tt * curve.control2.y;
              y += ttt * curve.endPoint.y;
              var width = Math.min(curve.startWidth + ttt * widthDelta, this.maxWidth);

              this._drawCurveSegment(x, y, width);
            }

            ctx.closePath();
            ctx.fill();
          }
        }, {
          key: "_drawDot",
          value: function _drawDot(_ref4) {
            var color = _ref4.color,
                point = _ref4.point;
            var ctx = this._ctx;
            var width = typeof this.dotSize === 'function' ? this.dotSize() : this.dotSize;
            ctx.beginPath();

            this._drawCurveSegment(point.x, point.y, width);

            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
          }
        }, {
          key: "_fromData",
          value: function _fromData(pointGroups, drawCurve, drawDot) {
            var _iterator = _createForOfIteratorHelper(pointGroups),
                _step;

            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var group = _step.value;
                var color = group.color,
                    points = group.points;

                if (points.length > 1) {
                  for (var j = 0; j < points.length; j += 1) {
                    var basicPoint = points[j];
                    var point = new Point(basicPoint.x, basicPoint.y, basicPoint.time);
                    this.penColor = color;

                    if (j === 0) {
                      this._reset();
                    }

                    var curve = this._addPoint(point);

                    if (curve) {
                      drawCurve({
                        color: color,
                        curve: curve
                      });
                    }
                  }
                } else {
                  this._reset();

                  drawDot({
                    color: color,
                    point: points[0]
                  });
                }
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
          }
        }, {
          key: "_toSVG",
          value: function _toSVG() {
            var _this4 = this;

            var pointGroups = this._data;
            var ratio = Math.max(window.devicePixelRatio || 1, 1);
            var minX = 0;
            var minY = 0;
            var maxX = this.canvas.width / ratio;
            var maxY = this.canvas.height / ratio;
            var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', this.canvas.width.toString());
            svg.setAttribute('height', this.canvas.height.toString());

            this._fromData(pointGroups, function (_ref5) {
              var color = _ref5.color,
                  curve = _ref5.curve;
              var path = document.createElement('path');

              if (!isNaN(curve.control1.x) && !isNaN(curve.control1.y) && !isNaN(curve.control2.x) && !isNaN(curve.control2.y)) {
                var attr = "M ".concat(curve.startPoint.x.toFixed(3), ",").concat(curve.startPoint.y.toFixed(3), " ") + "C ".concat(curve.control1.x.toFixed(3), ",").concat(curve.control1.y.toFixed(3), " ") + "".concat(curve.control2.x.toFixed(3), ",").concat(curve.control2.y.toFixed(3), " ") + "".concat(curve.endPoint.x.toFixed(3), ",").concat(curve.endPoint.y.toFixed(3));
                path.setAttribute('d', attr);
                path.setAttribute('stroke-width', (curve.endWidth * 2.25).toFixed(3));
                path.setAttribute('stroke', color);
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke-linecap', 'round');
                svg.appendChild(path);
              }
            }, function (_ref6) {
              var color = _ref6.color,
                  point = _ref6.point;
              var circle = document.createElement('circle');
              var dotSize = typeof _this4.dotSize === 'function' ? _this4.dotSize() : _this4.dotSize;
              circle.setAttribute('r', dotSize.toString());
              circle.setAttribute('cx', point.x.toString());
              circle.setAttribute('cy', point.y.toString());
              circle.setAttribute('fill', color);
              svg.appendChild(circle);
            });

            var prefix = 'data:image/svg+xml;base64,';
            var header = '<svg' + ' xmlns="http://www.w3.org/2000/svg"' + ' xmlns:xlink="http://www.w3.org/1999/xlink"' + " viewBox=\"".concat(minX, " ").concat(minY, " ").concat(maxX, " ").concat(maxY, "\"") + " width=\"".concat(maxX, "\"") + " height=\"".concat(maxY, "\"") + '>';
            var body = svg.innerHTML;

            if (body === undefined) {
              var dummy = document.createElement('dummy');
              var nodes = svg.childNodes;
              dummy.innerHTML = '';

              for (var i = 0; i < nodes.length; i += 1) {
                dummy.appendChild(nodes[i].cloneNode(true));
              }

              body = dummy.innerHTML;
            }

            var footer = '</svg>';
            var data = header + body + footer;
            return prefix + btoa(data);
          }
        }]);

        return SignaturePad;
      }();
      /* harmony default export */


      __webpack_exports__["default"] = SignaturePad;
      /***/
    }
  }]);
})();
//# sourceMappingURL=default-node_modules_signature_pad_dist_signature_pad_js-es5.js.map